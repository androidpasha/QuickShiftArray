#Библиотека сдвигового массива QuickShiftArray.
---
Основное преимущество над классическим массивом скорость сдвига в 50 раз быстрее.
(например был массив 0123 при сдвиге влево на 1 вышло 1230)
Присутствует функция push_back и push_front для добавления новых данных в края массива,
при этом массив сдвигается влево(вправо) на один элемент. противоположный вставке
элемент исчезает.
---
При создании экземпляра на куче выделяется память под новый массив.
Библиотека хранит номер элемента, с которого при вызове оператора [index]
начинается отсчет "нулевого элемента для пользователя". При сдвиге массива
изменяется номер элемента начала отсчета вместо перезаписи всего массива.
---
Присутствует конструктор копии для передачи массива по значению.
При удалении массива (окончание блока кода {}) вызывается деструктор
который освобождает память на куче.
Класс QuickShiftArray шаблонный и может создавать массивы с любыми типами данных:
QuickShiftArray<ТИП_ДАННЫХ> НАЗВАНИЕ_МАССИВА(КОЛИЧЕСТВО_ЯЧЕЕК);
Обращение к ячейкам как в обычном массиве: НАЗВАНИЕ_МАССИВА[ИНДЕКС];
Добавление новых данных в конец со сдвигом массива влево:
НАЗВАНИЕ_МАССИВА.push_back(НОВОЕ_ЗНАЧЕНИЕ);
Добавление новых данных в начало со сдвигом массива вправо:
НАЗВАНИЕ_МАССИВА.push_front(НОВОЕ_ЗНАЧЕНИЕ);
---
Сдвиг массива: НАЗВАНИЕ_МАССИВА << КОЛИЧЕСТВО_ШАГОВ_СДВИГА;
НАЗВАНИЕ_МАССИВА >> КОЛИЧЕСТВО_ШАГОВ_СДВИГА;
Количество ячеек в массиве size_t: НАЗВАНИЕ_МАССИВА.size();
Пройтись по всем элементам: for(size_t i = 0; i < НАЗВАНИЕ_МАССИВА.size(); i++){}
---
###Недостатки:
Скорость доступа к элементам в 2 раза дольше чем у классического массива из-за подсчета индексов.
С QuickShiftArray не работает цикл по диапазону for(auto e: QuickShiftArray){} т.к. в реальности
доступ к ячейкам идет не последовательно и в крайнем индексе адрес следующей ячейки
начинается с противоположной стороны.

